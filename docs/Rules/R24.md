# Smell: Index Column Not Explicitly Set in Data-Frame Reads

## Motivation  

`pd.read_csv, pd.read_table, pd.read_excel, …` all create a
DataFrame whose index defaults to a monotonically increasing integer
`(0… n-1)` when the caller does not supply `index_col= (or set_index
right after)`. 

Consequences:

Hidden duplicates or mis-alignments when you later prepend / concat
more rows.  

Merge / join operations that silently fall back to positional matching
instead of a semantic key.  

Extra memory when you later `df.set_index("id")` (the old integer
index is kept until garbage-collected).

Best practice is to tell pandas which column is the index at read
time:

```python
df = pd.read_csv("sales.csv", index_col="invoice_id")     #  explicit
```

Without it you risk:

- wasted compute time after the validation loss stagnates,  
- over-fitted weights and poorer generalisation,  
- tedious manual monitoring of the training curves.


---

## Detection strategy (high‑level view)

1. **AST parsing**  
   Parse the source and enrich nodes with parent pointers `(add_parent_info)`.

2. **Spot I/O calls**  
    `isPandasReadCall(node)` returns `True` for `pd.read_csv(...), pandas.read_parquet(...)`, etc.

3. **Look for the keyword**
    `hasKeyword(node, "index_col")` return False; the call is suspicious.

4. **Reporting**  

   REPORT: `pd.read_…` called without `index_col`; consider specifying `index_col` to avoid implicit integer indexing at line `n `.



---

## Practical meaning for the developer 


### Missing index specification
```python
df = pd.read_csv("customers.csv")     #  default RangeIndex(0…)
```

### Refactor
```python
df = pd.read_csv("customers.csv", index_col="customer_id")
```

### Missing index specification
```python
data = pd.read_parquet("logs.parquet")   # no primary key defined
```

### Refactor
```python
data = pd.read_parquet("logs.parquet", columns=["timestamp", "user_id", "event"])
data.set_index("timestamp", inplace=True)   # or index_col=0 if stored
```

---

## Limitations  

- The rule only inspects the call site; if you set the index immediately afterwards (`df.set_index(...)`) it will still warn.

- It assumes the import alias is `pd` or `pandas`; exotic aliases
  (import pandas as pds) are not detected.
  
- Custom wrapper functions around the read call (e.g. `load_csv(...)`)
  are out of scope unless added to the pattern list.

