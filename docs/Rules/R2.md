# Smell: “Random Seed Not Set”

## Motivation  
Re-running a machine-learning experiment should always produce the same
result.  
When randomness is involved (data shuffling, weight initialisation, Monte-Carlo
sampling, …) this is only guaranteed if the developer explicitly **fixes the
pseudo-random seed**.  Forgetting to do so jeopardises reproducibility and may
invalidate empirical findings.

## What the detector looks for  

The rule searches the analysed file for *two complementary situations*:

1. **Low-level sources of randomness**  
   • `numpy.random.*` functions  
   • pure-Python `random.*` calls  
   • `torch.rand*`, `torch.randint*`, `DataLoader(shuffle=True)`  
   • `tf.random.*` utilities  
2. **High-level scikit-learn APIs that hide randomness behind a
   `random_state` parameter**, e.g.  
   `RandomForestClassifier`, `KMeans`, `train_test_split`, …

## Detection strategy (conceptual view)

1. **AST parsing**  
   The whole file is converted into Python’s Abstract Syntax Tree (AST).

2. **Identification of “random” calls**  
   During a single walk through the AST the rule classifies every
   function-call node:  
   • If it belongs to one of the low-level random namespaces listed above,
     it is marked as a *random operation*.  
   • If it is an instantiation or a helper such as
     `RandomForestClassifier(…)`, it is marked as a *random algorithm*.

3. **Seed / parameter verification**  
   • For each *random operation* the detector checks beforehand whether a
     global seed setter was invoked for the same library in the file
     (`np.random.seed`, `torch.manual_seed`, `tf.random.set_seed`,
     `random.seed`).  
   • For each *random algorithm* it checks whether the call provides a
     non-null `random_state` keyword argument.

4. **Reporting**  
   If a random source lacks the corresponding seed configuration, the tool
   records the line number and issues the warning  
   “Random Seed Not Set at line X”.

## Practical interpretation  
A report means that the run-to-run behaviour of the code depends on an
*uncontrolled* source of randomness.  The user should either  
* add a proper global seed call (for NumPy, TensorFlow, PyTorch, Python
  `random`), or  
* supply a `random_state` argument to the scikit-learn constructor / helper.

## Limitations  
• The rule scans single files; if a seed is set in another module and imported
  later it may raise a false positive.  
• It assumes the conventional aliases (`import numpy as np`, `import torch`,
  `import tensorflow as tf`). Unusual naming conventions are not detected.
