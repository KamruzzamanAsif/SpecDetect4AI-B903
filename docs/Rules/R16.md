# Smell: API Call Result Discarded / Missing inplace=True

## Motivation  

Many Pandas DataFrame methods (e.g. `drop, sort_values`) and NumPy functions (`clip, sort, …`) return a new object unless you either:

capture the result (`df = df.drop(...)`) or pass the keyword `inplace=True` (for the Pandas methods that support it).

If neither is done, the call becomes a no‑op – the computation runs but its
result is silently thrown away.

 In data‑cleaning pipelines this leads to hard‑to‑spot bugs where a transformation “looks right” in the code but never takes effect.

---

## Detection strategy (high‑level view)

1. **AST parsing**  
   The source file is transformed into its Abstract Syntax Tree so each
   constructor call can be inspected structurally.

2. **API call identification**  
  A node is marked as a suspect API call when all three conditions hold:
  • it is an `ast.Call`;
  • the function is an attribute whose name is in the curated list of mutable‑looking APIs (`Pandas drop, replace, sort_values, NumPy clip, sort, …`);
• its base object is recognised as a Pandas DataFrame or the call
is a NumPy free function.

3. **Usage check**
    For each such call we ask:

    Is the keyword `inplace=True ` present?

    OR is the result `assigned / consumed`? (i.e. the call sits inside an
    assignment, a return, another call, etc.)

    If neither is true – the call is a bare statement like `df.drop("col")`; it is flagged.

4. **Reporting**  

   When such a node is found the detector emits 
   REPORT: API call might be missing reassignment or inplace=True at line `n `
---



---

## Practical meaning for the developer 



```python
# BEFORE – the drop never sticks
orders.drop("tmp")            # nothing happens

# AFTER  – two correct options
orders = orders.drop("tmp")   # capture the returned DF
# …or…
orders.drop("tmp", inplace=True)  # modify in place
```

The same principle applies to NumPy:

```python
# BEFORE – result ignored
np.sort(arr)

# AFTER – capture it
arr = np.sort(arr)
```

Making the choice explicit eliminates “ghost bugs” where a cleaning step seems
present but has no effect.
---

## Limitations  

- Only the `built‑in` lists of Pandas/NumPy mutating functions are analysed; user
wrappers (e.g. clean_df(df)) are not inspected.

- The check is conservative – some APIs (e.g. `Pandas plot`) legitimately
discard their result; these will not be flagged because they’re missing from
the curated list.

- Exotic Pandas aliases (import pandas as foo_pd) may escape detection.