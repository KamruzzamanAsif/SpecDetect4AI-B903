# Smell: NaN Comparison

## Motivation  

`np.nan` represents missing data. By definition, a NaN is not equal to anything – even to itself (`np.nan == np.nan` is False).
Comparing values directly to np.nan therefore:
Never does what the author intends – the comparison is always False (or True for !=).
Masks real problems: silent logic errors, incorrect filtering, and downstream bugs.
Instead, use the explicit “is-missing” predicates provided by NumPy / Pandas:
NumPy → `np.isnan(arr)`
Pandas → `Series.isna()` / `Series.notna()` / `DataFrame.isna()`


---

## Detection strategy (high‑level view)

1. **AST parsing**  
   The source file is transformed into its Abstract Syntax Tree so each
   constructor call can be inspected structurally.

2. **Locate comparison nodes**  
     Every `ast.Compare` node is inspected.

3. **Find `np.nan` operands**
    a comparison is flagged when either side is an attribute access of the form `np.nan`.

4. **Reporting**  

   When such a node is found the detector emits 
   REPORT: Do not compare with np.nan. Use df.isna() instead at line `n `
---





## Practical meaning for the developer 


### Numpy
```python
# BEFORE – broken mask
mask = arr == np.nan          # always False
clean = arr[~mask]            # keeps ALL rows!

# AFTER  – correct mask
mask = np.isnan(arr)
clean = arr[~mask]

```

### Pandas

```python
# BEFORE – logic bug
bad_rows = df[df["amount"] != np.nan]   # returns the FULL DataFrame

# AFTER  – explicit is-missing test
bad_rows = df[df["amount"].notna()]

```

---

## Limitations  

- The rule purposely doesn’t warn about `math.isnan()` or `pd.isna()`, which are correct.
- Very rarely a comparison to `np.nan` is used in a didactic context (e.g. teaching). Those will still be flagged; the developer can ignore the warning in that case.

