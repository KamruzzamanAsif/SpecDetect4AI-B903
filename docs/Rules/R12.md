# Smell: Matrix Multiplication API Misused

## Motivation  

`np.dot()` has *legacy* behaviour that varies with the dimensionality of the
operands—​for 2‑D arrays it does a matrix product, for 1‑D arrays a
vector dot‑product, and for *N*‑D arrays it performs a sum product over the
last axis of each input.  
Using it on 2‑D feature matrices therefore **hides intent** and increases the
risk of subtle bugs when the shape of the data changes.  
Modern NumPy code should rely on:

* `np.matmul(A, B)` – explicit matrix product,  
* or the infix `@` operator.

Doing so improves readability and guards against silent shape errors.

---

## Detection strategy (high‑level view)

1. **AST parsing**  
   The source file is transformed into its Abstract Syntax Tree so each
   constructor call can be inspected structurally.

2. **Locate `np.dot` calls**  
   A node is considered a dot call when:
   • it is an `ast.Call`, and
   • its fully‑qualified name resolves to `np.dot` (standard alias).


3. **Heuristic 2‑D check**  
   The call is flagged when it passes exactly **two positional arguments** –
   the typical signature for matrix multiplication.  (A future enhancement
   could analyse the shapes, but static analysis rarely has that information.)
4. **Reporting**  

   When such a node is found the detector emits 
   REPORT: Use `np.matmul()` instead of `np.dot()` for matrices at line nwhere `n` is the precise line number of the offending call.
---



---

## Practical meaning for the developer 


Replace the call with the explicit matrix product operator:

# BEFORE – prone to confusion
```python
C = np.dot(A, B)
```

# AFTER  – unambiguous
```python
C = A @ B              # or: np.matmul(A, B)
```

Using `@ / matmul` makes the intent crystal‑clear, supports broadcasting with
higher‑dimensional tensors and aligns the code with modern NumPy idioms.

---

## Limitations  

- The rule assumes that a two‑argument `np.dot` targets matrices; it may raise
a false positive when the arrays are strictly 1‑D (inner product).

- Static analysis cannot verify the runtime ranks—manual review is still
warranted.

